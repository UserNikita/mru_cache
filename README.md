# MRU кэш

## Задача

- Реализуовать MRU кэш стандартными средствами Python
- Сделать декоратор, в который можно будет обернуть функцию
- Смысл кэша в том, чтобы избежать лишних расчетов и выдать результат быстрее
- В качестве аргументов функций могут быть любые объекты (числа, строки, списки, кортежи и даже кастомные объекты)

## Реализация

Создано 2 класса MRU кэша. Cоздан декоратор `mru_cache`. 
Обеспечена возможность передавать любые объекты в любом количестве как с помощью 
позиционных аргументов, так и с помощью именованных.

Декоратор может применяться к функции с указанием конфигурационных параметров, а так же без них.
Параметрами являются `size` и `optimization`. 

`size` отвечает за размер кэша. Есть значение по умолчанию на случай, если пользователь не передал параметры.
Если `size` задан в значение меньшее или равное 0 или любое другое не типа `int`, то декоратор не будет применяться
и кэш не будет использоваться. 
Использование исключений может сделать поведение декоратора более явным, но в данной реализации это не было 
приоритетной задачей

`optimization` данный параметр появился так как не было понимания с каким размером кэша будет использоваться
декоратор и с объектами какого типа.

Так как некоторые объекты в питоне не могут быть использованы в качестве ключей в словаре, то единственный 
вариант сохранить их это просто добавить в список вместе с вычесленным значением.
В обычном кэше начение вычисляется и кладётся в список вместе с ключём, который не подвергается никаким
изменениям. При попытке получить значение из кэша, перебираются все сохранённые элементы и при первом же совпадении
ключа (они сравниваются оператором `==`) возвращается найденное значение и запоминается индекс в списке по которому
расположено это значение.
При заполнении кэша его элементы начинают перезаписываться. Для этого на предыдущем шаге произошло 
сохранение индекса последнего использованного элемента.

В случае с оптимизированным кэшем ключ сначала будет сериализован с помощью pickle, затем для уменьшения
размера байтовой строки она хешируется алгоритмом sha256. После чего вычесленное значение добавляется в список, 
а хешированный ключ сохраняется в словарь. Когда происходит обращение к кэшу для получения элемента, то ключ сначала
проходит тот же этап сериализации и ищется в словаре сериализованных ключей. Если он там есть, то мы получаем значение
этого словаря, то есть индекс элемента в списке сохранённых значений. Там же лежит и исходный объект.
Для точности происходит сравнение с исходным объектом, так как некоторые объекты могут быть не равны друг другу, но
после сериализации преобразуются в одинаковые хеши (пример, `object()`). Если объекты не равны, то предпринимаем 
попытку найти объект в списке с помощью полного перебора, как в обычной реализации кэша.
Если в словаре сериализованных ключей не нашёлся искомый ключ или он не подлежит сериализации, то просто вносится
в список кэшированных данных вместе со значением, как это бывает при неоптимизированном кэше. Последний вариант 
актуален для функций, так как они могут быть аргументами других функций, но при этом их нельзя сериализовать с
помощью pickle.
Благодаря этой оптимизации поиск большинства ключей имеет сложность O(1) (получение значений из словаря по ключу,
получение элемента в списке по индексу и сравнение объектов). В редких случаях происходит полный перебор. В общем
случае оптимизированный вариант в теории более производительный чем обычный. 
Обычный вариант сделан для того, чтобы иметь простую реализацию (без sha256 и pickle) кэша с меньшим количеством кода.

## Запуск тестов

```bash
python -m unittest discover -v
```